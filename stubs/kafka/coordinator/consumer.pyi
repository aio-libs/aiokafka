from kafka.coordinator.assignors.range import RangePartitionAssignor as RangePartitionAssignor
from kafka.coordinator.assignors.roundrobin import RoundRobinPartitionAssignor as RoundRobinPartitionAssignor
from kafka.coordinator.base import BaseCoordinator as BaseCoordinator, Generation as Generation
from kafka.coordinator.protocol import ConsumerProtocol as ConsumerProtocol
from kafka.future import Future as Future
from kafka.metrics import AnonMeasurable as AnonMeasurable
from kafka.metrics.stats import Avg as Avg, Count as Count, Max as Max, Rate as Rate
from kafka.protocol.commit import OffsetCommitRequest as OffsetCommitRequest, OffsetFetchRequest as OffsetFetchRequest
from kafka.structs import OffsetAndMetadata as OffsetAndMetadata, TopicPartition as TopicPartition
from typing import Any, Optional

log: Any

class ConsumerCoordinator(BaseCoordinator):
    DEFAULT_CONFIG: Any = ...
    config: Any = ...
    auto_commit_interval: Any = ...
    next_auto_commit_deadline: Any = ...
    completed_offset_commits: Any = ...
    consumer_sensors: Any = ...
    def __init__(self, client: Any, subscription: Any, metrics: Any, **configs: Any) -> None: ...
    def __del__(self) -> None: ...
    def protocol_type(self): ...
    def group_protocols(self): ...
    def poll(self) -> None: ...
    def time_to_next_poll(self): ...
    def need_rejoin(self): ...
    def refresh_committed_offsets_if_needed(self) -> None: ...
    def fetch_committed_offsets(self, partitions: Any): ...
    def close(self, autocommit: bool = ...) -> None: ...
    def commit_offsets_async(self, offsets: Any, callback: Optional[Any] = ...): ...
    def commit_offsets_sync(self, offsets: Any): ...

class ConsumerCoordinatorMetrics:
    metrics: Any = ...
    metric_group_name: Any = ...
    commit_latency: Any = ...
    def __init__(self, metrics: Any, metric_group_prefix: Any, subscription: Any): ...
