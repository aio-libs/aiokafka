import abc
import threading
from kafka import errors as Errors
from kafka.coordinator.heartbeat import Heartbeat as Heartbeat
from kafka.future import Future as Future
from kafka.metrics import AnonMeasurable as AnonMeasurable
from kafka.metrics.stats import Avg as Avg, Count as Count, Max as Max, Rate as Rate
from kafka.protocol.commit import GroupCoordinatorRequest as GroupCoordinatorRequest, OffsetCommitRequest as OffsetCommitRequest
from kafka.protocol.group import HeartbeatRequest as HeartbeatRequest, JoinGroupRequest as JoinGroupRequest, LeaveGroupRequest as LeaveGroupRequest, SyncGroupRequest as SyncGroupRequest
from typing import Any, Optional

log: Any

class MemberState:
    UNJOINED: str = ...
    REBALANCING: str = ...
    STABLE: str = ...

class Generation:
    generation_id: Any = ...
    member_id: Any = ...
    protocol: Any = ...
    def __init__(self, generation_id: Any, member_id: Any, protocol: Any) -> None: ...

class UnjoinedGroupException(Errors.KafkaError):
    retriable: bool = ...

class BaseCoordinator(metaclass=abc.ABCMeta):
    DEFAULT_CONFIG: Any = ...
    config: Any = ...
    group_id: Any = ...
    heartbeat: Any = ...
    rejoin_needed: bool = ...
    rejoining: bool = ...
    state: Any = ...
    join_future: Any = ...
    coordinator_id: Any = ...
    sensors: Any = ...
    def __init__(self, client: Any, metrics: Any, **configs: Any) -> None: ...
    @abc.abstractmethod
    def protocol_type(self) -> Any: ...
    @abc.abstractmethod
    def group_protocols(self) -> Any: ...
    def coordinator_unknown(self): ...
    def coordinator(self): ...
    def ensure_coordinator_ready(self) -> None: ...
    def lookup_coordinator(self): ...
    def need_rejoin(self): ...
    def poll_heartbeat(self) -> None: ...
    def time_to_next_heartbeat(self): ...
    def ensure_active_group(self) -> None: ...
    def coordinator_dead(self, error: Any) -> None: ...
    def generation(self): ...
    def reset_generation(self) -> None: ...
    def request_rejoin(self) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...
    def maybe_leave_group(self) -> None: ...

class GroupCoordinatorMetrics:
    heartbeat: Any = ...
    metrics: Any = ...
    metric_group_name: Any = ...
    heartbeat_latency: Any = ...
    join_latency: Any = ...
    sync_latency: Any = ...
    def __init__(self, heartbeat: Any, metrics: Any, prefix: Any, tags: Optional[Any] = ...): ...

class HeartbeatThread(threading.Thread):
    name: Any = ...
    coordinator: Any = ...
    enabled: bool = ...
    closed: bool = ...
    failed: Any = ...
    def __init__(self, coordinator: Any) -> None: ...
    def enable(self) -> None: ...
    def disable(self) -> None: ...
    def close(self) -> None: ...
    def run(self) -> None: ...
