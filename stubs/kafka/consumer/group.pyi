import six
from kafka.client_async import KafkaClient as KafkaClient
from kafka.consumer.fetcher import Fetcher as Fetcher
from kafka.consumer.subscription_state import SubscriptionState as SubscriptionState
from kafka.coordinator.assignors.range import RangePartitionAssignor as RangePartitionAssignor
from kafka.coordinator.assignors.roundrobin import RoundRobinPartitionAssignor as RoundRobinPartitionAssignor
from kafka.coordinator.consumer import ConsumerCoordinator as ConsumerCoordinator
from kafka.errors import KafkaConfigurationError as KafkaConfigurationError, UnsupportedVersionError as UnsupportedVersionError
from kafka.metrics import MetricConfig as MetricConfig, Metrics as Metrics
from kafka.protocol.offset import OffsetResetStrategy as OffsetResetStrategy
from kafka.structs import TopicPartition as TopicPartition
from typing import Any, Optional

log: Any

class KafkaConsumer(six.Iterator):
    DEFAULT_CONFIG: Any = ...
    DEFAULT_SESSION_TIMEOUT_MS_0_9: int = ...
    config: Any = ...
    def __init__(self, *topics: Any, **configs: Any) -> None: ...
    def bootstrap_connected(self): ...
    def assign(self, partitions: Any) -> None: ...
    def assignment(self): ...
    def close(self, autocommit: bool = ...) -> None: ...
    def commit_async(self, offsets: Optional[Any] = ..., callback: Optional[Any] = ...): ...
    def commit(self, offsets: Optional[Any] = ...) -> None: ...
    def committed(self, partition: Any, metadata: bool = ...): ...
    def topics(self): ...
    def partitions_for_topic(self, topic: Any): ...
    def poll(self, timeout_ms: int = ..., max_records: Optional[Any] = ..., update_offsets: bool = ...): ...
    def position(self, partition: Any): ...
    def highwater(self, partition: Any): ...
    def pause(self, *partitions: Any) -> None: ...
    def paused(self): ...
    def resume(self, *partitions: Any) -> None: ...
    def seek(self, partition: Any, offset: Any) -> None: ...
    def seek_to_beginning(self, *partitions: Any) -> None: ...
    def seek_to_end(self, *partitions: Any) -> None: ...
    def subscribe(self, topics: Any = ..., pattern: Optional[Any] = ..., listener: Optional[Any] = ...) -> None: ...
    def subscription(self): ...
    def unsubscribe(self) -> None: ...
    def metrics(self, raw: bool = ...): ...
    def offsets_for_times(self, timestamps: Any): ...
    def beginning_offsets(self, partitions: Any): ...
    def end_offsets(self, partitions: Any): ...
    def __iter__(self) -> Any: ...
    def __next__(self): ...
    def next_v2(self): ...
    def next_v1(self): ...
