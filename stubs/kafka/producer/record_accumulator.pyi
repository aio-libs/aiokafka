from kafka.producer.buffer import SimpleBufferPool as SimpleBufferPool
from kafka.producer.future import FutureProduceResult as FutureProduceResult, FutureRecordMetadata as FutureRecordMetadata
from kafka.record.memory_records import MemoryRecordsBuilder as MemoryRecordsBuilder
from kafka.structs import TopicPartition as TopicPartition
from typing import Any, Optional

log: Any

class AtomicInteger:
    def __init__(self, val: int = ...) -> None: ...
    def increment(self): ...
    def decrement(self): ...
    def get(self): ...

class ProducerBatch:
    max_record_size: int = ...
    created: Any = ...
    drained: Any = ...
    attempts: int = ...
    last_attempt: Any = ...
    last_append: Any = ...
    records: Any = ...
    topic_partition: Any = ...
    produce_future: Any = ...
    def __init__(self, tp: Any, records: Any, buffer: Any) -> None: ...
    @property
    def record_count(self): ...
    def try_append(self, timestamp_ms: Any, key: Any, value: Any, headers: Any): ...
    def done(self, base_offset: Optional[Any] = ..., timestamp_ms: Optional[Any] = ..., exception: Optional[Any] = ...) -> None: ...
    def maybe_expire(self, request_timeout_ms: Any, retry_backoff_ms: Any, linger_ms: Any, is_full: Any): ...
    def in_retry(self): ...
    def set_retry(self) -> None: ...
    def buffer(self): ...

class RecordAccumulator:
    DEFAULT_CONFIG: Any = ...
    config: Any = ...
    muted: Any = ...
    def __init__(self, **configs: Any) -> None: ...
    def append(self, tp: Any, timestamp_ms: Any, key: Any, value: Any, headers: Any, max_time_to_block_ms: Any, estimated_size: int = ...): ...
    def abort_expired_batches(self, request_timeout_ms: Any, cluster: Any): ...
    def reenqueue(self, batch: Any) -> None: ...
    def ready(self, cluster: Any): ...
    def has_unsent(self): ...
    def drain(self, cluster: Any, nodes: Any, max_size: Any): ...
    def deallocate(self, batch: Any) -> None: ...
    def begin_flush(self) -> None: ...
    def await_flush_completion(self, timeout: Optional[Any] = ...) -> None: ...
    def abort_incomplete_batches(self) -> None: ...
    def close(self) -> None: ...

class IncompleteProducerBatches:
    def __init__(self) -> None: ...
    def add(self, batch: Any): ...
    def remove(self, batch: Any): ...
    def all(self): ...
