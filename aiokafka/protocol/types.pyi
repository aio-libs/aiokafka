from collections.abc import Sequence
from io import BytesIO
from typing import Any, TypeVar, overload

from typing_extensions import TypeAlias

from .abstract import AbstractType

T = TypeVar("T")
ValueT: TypeAlias = type[AbstractType[Any]] | "String" | "Array" | "Schema"

class Int8(AbstractType[int]):
    _pack = ...
    _unpack = ...
    @classmethod
    def encode(cls, value: int) -> bytes: ...
    @classmethod
    def decode(cls, data: BytesIO) -> int: ...

class Int16(AbstractType[int]):
    _pack = ...
    _unpack = ...
    @classmethod
    def encode(cls, value: int) -> bytes: ...
    @classmethod
    def decode(cls, data: BytesIO) -> int: ...

class Int32(AbstractType[int]):
    _pack = ...
    _unpack = ...
    @classmethod
    def encode(cls, value: int) -> bytes: ...
    @classmethod
    def decode(cls, data: BytesIO) -> int: ...

class UInt32(AbstractType[int]):
    _pack = ...
    _unpack = ...
    @classmethod
    def encode(cls, value: int) -> bytes: ...
    @classmethod
    def decode(cls, data: BytesIO) -> int: ...

class Int64(AbstractType[int]):
    _pack = ...
    _unpack = ...
    @classmethod
    def encode(cls, value: int) -> bytes: ...
    @classmethod
    def decode(cls, data: BytesIO) -> int: ...

class Float64(AbstractType[float]):
    _pack = ...
    _unpack = ...
    @classmethod
    def encode(cls, value: float) -> bytes: ...
    @classmethod
    def decode(cls, data: BytesIO) -> float: ...

class String:
    def __init__(self, encoding: str = ...) -> None: ...
    def encode(self, value: str | None) -> bytes: ...
    def decode(self, data: BytesIO) -> str | None: ...
    @classmethod
    def repr(cls, value: str) -> str: ...

class Bytes(AbstractType[bytes | None]):
    @classmethod
    def encode(cls, value: bytes | None) -> bytes: ...
    @classmethod
    def decode(cls, data: BytesIO) -> bytes | None: ...
    @classmethod
    def repr(cls, value: bytes | None) -> str: ...

class Boolean(AbstractType[bool]):
    _pack = ...
    _unpack = ...
    @classmethod
    def encode(cls, value: bool) -> bytes: ...
    @classmethod
    def decode(cls, data: BytesIO) -> bool: ...

class Schema:
    names: tuple[str, ...]
    fields: tuple[ValueT, ...]
    def __init__(self, *fields: tuple[str, ValueT]) -> None: ...
    def encode(self, item: Sequence[Any]) -> bytes: ...
    def decode(
        self, data: BytesIO
    ) -> tuple[Any | str | None | list[Any | tuple[Any, ...]], ...]: ...
    def __len__(self) -> int: ...
    def repr(self, value: Any) -> str: ...

class Array:
    array_of: ValueT
    @overload
    def __init__(self, array_of_0: ValueT) -> None: ...
    @overload
    def __init__(
        self, array_of_0: tuple[str, ValueT], *array_of: tuple[str, ValueT]
    ) -> None: ...
    def __init__(
        self,
        array_of_0: ValueT | tuple[str, ValueT],
        *array_of: tuple[str, ValueT],
    ) -> None: ...
    def encode(self, items: Sequence[Any] | None) -> bytes: ...
    def decode(self, data: BytesIO) -> list[Any | tuple[Any, ...]] | None: ...
    def repr(self, list_of_items: Sequence[Any] | None) -> str: ...

class UnsignedVarInt32(AbstractType[int]):
    @classmethod
    def decode(cls, data: BytesIO) -> int: ...
    @classmethod
    def encode(cls, value: int) -> bytes: ...

class VarInt32(AbstractType[int]):
    @classmethod
    def decode(cls, data: BytesIO) -> int: ...
    @classmethod
    def encode(cls, value: int) -> bytes: ...

class VarInt64(AbstractType[int]):
    @classmethod
    def decode(cls, data: BytesIO) -> int: ...
    @classmethod
    def encode(cls, value: int) -> bytes: ...

class CompactString(String):
    def decode(self, data: BytesIO) -> str | None: ...
    def encode(self, value: str | None) -> bytes: ...

class TaggedFields(AbstractType[dict[int, bytes]]):
    @classmethod
    def decode(cls, data: BytesIO) -> dict[int, bytes]: ...
    @classmethod
    def encode(cls, value: dict[int, bytes]) -> bytes: ...

class CompactBytes(AbstractType[bytes | None]):
    @classmethod
    def decode(cls, data: BytesIO) -> bytes | None: ...
    @classmethod
    def encode(cls, value: bytes | None) -> bytes: ...

class CompactArray(Array):
    def encode(self, items: Sequence[Any] | None) -> bytes: ...
    def decode(self, data: BytesIO) -> list[Any | tuple[Any, ...]] | None: ...
